\"\"\"Service for managing context snapshots in memory and database.\"\"\"\n\nimport logging\nimport uuid\nfrom collections import deque\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, Optional, List, Deque, Tuple\n\nfrom ..schemas.context_schemas import (\n    ContextSnapshotSchema, ContextSnapshotResponse, ContextStats, FileDataSchema\n)\nfrom ..db_core.models import SnapshotLog, ContextSnapshot, FileData, DiagnosticItem\nfrom ..db_core import crud\nfrom ..db_core.base import AsyncSession\n\nlogger = logging.getLogger(__name__)\n\nclass ContextCacheService:\n    \"\"\"Manages context snapshots, storing recent ones in memory and persisting to DB.\"\"\"\n\n    def __init__(self, db_session: AsyncSession, max_memory_snapshots: int = 10):\n        \"\"\"Initialize the service.\n        \n        Args:\n            db_session: The database session to use for persistence.\n            max_memory_snapshots: Max number of snapshots to keep in memory.\n        \"\"\"\n        self.db_session = db_session\n        self.max_memory_snapshots = max_memory_snapshots\n        # Use a deque for efficient addition/removal from both ends\n        self.snapshots_in_memory: Deque[Tuple[uuid.UUID, ContextSnapshotSchema]] = deque(maxlen=max_memory_snapshots)\n        self.snapshot_ids_in_memory = set()\n        \n        logger.info(f\"ContextCacheService initialized with max_memory_snapshots={max_memory_snapshots}\")\n\n    async def _store_snapshot_in_db(self, snapshot_data: ContextSnapshotSchema) -> uuid.UUID:\n        \"\"\"Persists a snapshot and its related data to the database.\"\"\"\n        try:\n            # 1. Create SnapshotLog entry\n            log_entry = await crud.create_snapshot_log(\n                self.db_session,\n                log_in=snapshot_data.log_entry # Assuming log data is nested\n            )\n            \n            # 2. Create ContextSnapshot entry linked to the log\n            # Convert Pydantic schema to dict suitable for ORM model\n            snapshot_create_data = snapshot_data.model_dump(\n                exclude={\'log_entry\', \'files\', \'diagnostics\'}\n            )\n             # Rename client_metadata if needed by schema vs model\n            if \'client_metadata\' in snapshot_create_data:\n                 snapshot_create_data[\'client_metadata\'] = snapshot_create_data.pop(\'client_metadata\', None)\n            \n            # Assuming the crud function handles nested FileData and DiagnosticItem creation\n            db_snapshot = await crud.create_context_snapshot(\n                self.db_session,\n                snapshot_in=snapshot_data, # Pass the full Pydantic object\n                log_id=log_entry.id\n            )\n            \n            logger.info(f\"Snapshot {db_snapshot.id} (Log ID: {log_entry.id}) persisted to database.\")\n            return db_snapshot.id # Return the actual snapshot ID\n        except Exception as e:\n            logger.exception(f\"Failed to store snapshot in database: {e}\")\n            # Optionally update log entry status to \'failed\' here\n            raise # Re-raise the exception\n\n    async def store_snapshot(self, snapshot_data: ContextSnapshotSchema) -> uuid.UUID:\n        \"\"\"Stores a snapshot in memory and triggers DB persistence.\"\"\"\n        # Store in memory first for quick access\n        snapshot_id = uuid.uuid4() # Generate ID upfront or get from DB?\ Getting from DB is safer.\n        \n        # Persist to DB (this will generate the definitive IDs)\n        db_snapshot_id = await self._store_snapshot_in_db(snapshot_data)\n        snapshot_id = db_snapshot_id # Use the ID from the database\n        \n        # Add to in-memory cache\n        if snapshot_id in self.snapshot_ids_in_memory:\n            # If somehow already present, remove old one first to update position\n            self.snapshots_in_memory = deque(\n                (sid, s) for sid, s in self.snapshots_in_memory if sid != snapshot_id\n            )\n            self.snapshot_ids_in_memory.remove(snapshot_id)\n            \n        self.snapshots_in_memory.append((snapshot_id, snapshot_data))\n        self.snapshot_ids_in_memory.add(snapshot_id)\n        \n        logger.debug(f\"Snapshot {snapshot_id} added to in-memory cache.\")\n        return snapshot_id\n\n    async def get_snapshot(self, snapshot_id: uuid.UUID) -> Optional[ContextSnapshotResponse]:\n        \"\"\"Retrieves a snapshot, checking memory first, then DB.\"\"\"\n        # Check memory cache\n        for sid, s_data in self.snapshots_in_memory:\n            if sid == snapshot_id:\n                logger.debug(f\"Snapshot {snapshot_id} found in memory cache.\")\n                # Convert Schema to Response model if necessary\n                # This might require adjusting schemas or adding conversion logic\n                return ContextSnapshotResponse.model_validate(s_data) # Example validation\n\n        # If not in memory, query the database\n        logger.debug(f\"Snapshot {snapshot_id} not in memory, querying database...\")\n        db_snapshot = await crud.get_context_snapshot(self.db_session, snapshot_id)\n        \n        if db_snapshot:\n            logger.debug(f\"Snapshot {snapshot_id} found in database.\")\n            # Convert ORM model to Pydantic Response model\n            # This requires careful mapping, especially for relationships\n            response_data = {\n                **db_snapshot.__dict__,\n                \"log_entry\": db_snapshot.log_entry.__dict__ if db_snapshot.log_entry else None,\n                \"files\": [FileDataSchema.model_validate(f) for f in db_snapshot.files or []],\n                \"diagnostics\": [d.__dict__ for d in db_snapshot.diagnostics or []],\n            }\n            # Remove SQLAlchemy internal state\n            response_data.pop(\'_sa_instance_state\', None)\n            if response_data[\"log_entry\"]:\n                 response_data[\"log_entry\"].pop(\'_sa_instance_state\', None)\n            for file_resp in response_data[\"files\"]:\n                 # Assuming FileDataSchema matches FileData model closely\n                 pass # No state to pop if using model_validate\n            for diag_resp in response_data[\"diagnostics\"]:\n                 diag_resp.pop(\'_sa_instance_state\', None)\n                 \n            return ContextSnapshotResponse.model_validate(response_data)\n        else:\n            logger.warning(f\"Snapshot {snapshot_id} not found in database.\")\n            return None\n\n    async def get_latest_snapshot(self) -> Optional[ContextSnapshotResponse]:\n        \"\"\"Retrieves the most recent snapshot (from memory if available).\"\"\"\n        if self.snapshots_in_memory:\n            latest_id, latest_data = self.snapshots_in_memory[-1]\n            logger.debug(f\"Returning latest snapshot {latest_id} from memory.\")\n            return ContextSnapshotResponse.model_validate(latest_data)\n        else:\n            # TODO: Query DB for the latest snapshot based on received_at or snapshot_time\n            logger.warning(\"In-memory cache is empty, DB query for latest not yet implemented.\")\n            # snapshots = await crud.get_context_snapshots(self.db_session, limit=1, order_by=desc(ContextSnapshot.snapshot_time))\n            # if snapshots: return await self.get_snapshot(snapshots[0].id)\n            return None\n\n    async def query_context(self, query: str) -> List[ContextSnapshotResponse]:\n        \"\"\"Queries context based on a description (placeholder for semantic search).\"\"\"\n        # TODO: Implement actual database querying, potentially semantic search/RAG.\n        # For now, return all snapshots in memory (or latest)\n        logger.warning(\"Context query uses placeholder logic (returns latest snapshot).\")\n        latest = await self.get_latest_snapshot()\n        return [latest] if latest else []\n\n    async def get_stats(self) -> ContextStats:\n        \"\"\"Gets statistics about the stored context.\"\"\"\n        # TODO: Query DB for total snapshot count\n        total_db_snapshots = 0 # await crud.count_snapshots(self.db_session) # Example\n        return ContextStats(\n            snapshots_in_memory=len(self.snapshots_in_memory),\n            total_snapshots_in_db=total_db_snapshots, # Placeholder\n            oldest_snapshot_time=self.snapshots_in_memory[0][1].snapshot_time if self.snapshots_in_memory else None,\n            newest_snapshot_time=self.snapshots_in_memory[-1][1].snapshot_time if self.snapshots_in_memory else None,\n        )\n\n    async def _load_recent_snapshots_from_db(self):\n        \"\"\"Loads recent snapshots from DB on startup (optional).\"\"\"\n        # TODO: Implement logic to load `max_memory_snapshots` most recent snapshots\n        # from the DB into the in-memory deque on service initialization.\n        logger.info(\"Loading recent snapshots from DB (not implemented).\" )\n        pass\n\n    async def _cleanup_old_snapshots_in_db(self, max_age: timedelta = timedelta(days=7)):\n        \"\"\"Periodically removes old snapshots from the database (optional).\"\"\"\n        # TODO: Implement logic to delete snapshots older than `max_age`.\n        logger.info(f\"Cleaning up snapshots older than {max_age} (not implemented).\")\n        pass\n\n    async def initialize(self):\n        \"\"\"Initialize the service, e.g., load recent snapshots.\"\"\"\n        await self._load_recent_snapshots_from_db()\n\n    async def shutdown(self):\n        \"\"\"Clean up resources on shutdown.\"\"\"\n        logger.info(\"Shutting down ContextCacheService.\")\n        # No explicit cleanup needed for deque/set\n        pass\n